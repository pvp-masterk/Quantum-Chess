<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Chess</title>
    <style>
        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(0, 255, 0, 0.4);
            --move-hint: rgba(0, 0, 255, 0.3);
            --power-move: rgba(255, 215, 0, 0.6);
            --danger: rgba(255, 0, 0, 0.4);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #222;
            color: white;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #333, #111);
            padding: 1rem;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(to right, #ff8a00, #e52e71);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1rem;
            color: #aaa;
            margin-top: 0.5rem;
        }
        
        .container {
            display: flex;
            flex: 1;
            padding: 1rem;
            gap: 1rem;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }
        
        .chess-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        #chessboard {
            width: 80vmin;
            height: 80vmin;
            max-width: 600px;
            max-height: 600px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .square {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .square.light {
            background-color: var(--light-square);
        }
        
        .square.dark {
            background-color: var(--dark-square);
        }
        
        .square.highlight {
            background-color: var(--highlight);
        }
        
        .square.move-hint {
            background-color: var(--move-hint);
            cursor: pointer;
        }
        
        .square.power-move {
            background-color: var(--power-move);
        }
        
        .square.danger {
            background-color: var(--danger);
        }
        
        .piece {
            width: 100%;
            height: 100%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: relative;
            z-index: 2;
            transition: transform 0.2s ease;
            cursor: grab;
        }
        
        .piece.dragging {
            transform: scale(1.2);
            z-index: 10;
            cursor: grabbing;
        }
        
        .piece.animate {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .coordinates {
            position: absolute;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        
        .coordinates.file {
            bottom: 2px;
            right: 4px;
        }
        
        .coordinates.rank {
            top: 2px;
            left: 4px;
        }
        
        .sidebar {
            width: 300px;
            background: linear-gradient(145deg, #333, #222);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        
        .panel {
            background: rgba(50, 50, 50, 0.7);
            border-radius: 6px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .panel h2 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #ddd;
            border-bottom: 1px solid #444;
            padding-bottom: 0.5rem;
        }
        
        .move-history {
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .move-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.3rem;
            font-size: 0.9rem;
        }
        
        .move-list div {
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .move-list div:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .move-list div.active {
            background: rgba(0, 150, 255, 0.3);
            font-weight: bold;
        }
        
        .status {
            font-size: 1rem;
            text-align: center;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(145deg, #444, #333);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 120px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: linear-gradient(145deg, #555, #444);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.primary {
            background: linear-gradient(145deg, #0066ff, #0055dd);
        }
        
        button.primary:hover {
            background: linear-gradient(145deg, #0077ff, #0066ee);
        }
        
        button.danger {
            background: linear-gradient(145deg, #ff3333, #dd2222);
        }
        
        button.danger:hover {
            background: linear-gradient(145deg, #ff4444, #ee3333);
        }
        
        .power-moves {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .power-moves button {
            font-size: 0.8rem;
            padding: 0.4rem 0.6rem;
            min-width: auto;
        }
        
        .timer {
            font-size: 1.5rem;
            text-align: center;
            font-family: monospace;
            margin: 0.5rem 0;
        }
        
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            margin-top: 0.5rem;
        }
        
        .captured-piece {
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.8;
        }
        
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                order: -1;
            }
            
            #chessboard {
                width: 90vmin;
                height: 90vmin;
            }
        }
        
        /* Animation classes */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }
        
        .pulse {
            animation: pulse 1.5s infinite;
        }
        
        .float {
            animation: float 3s ease-in-out infinite;
        }
        
        .glow {
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.7));
        }
        
        /* Special effects */
        .explosion {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,200,0,0.8) 0%, rgba(255,100,0,0.6) 50%, rgba(255,0,0,0) 70%);
            z-index: 5;
            opacity: 0;
            pointer-events: none;
        }
        
        /* Power move effects */
        .power-move-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,255,255,0.6) 0%, rgba(0,150,255,0.4) 50%, rgba(0,0,255,0) 70%);
            z-index: 3;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <header>
        <h1>Quantum Chess</h1>
        <div class="subtitle">Cooldude is gay</div>
    </header>
    
    <div class="container">
        <div class="chess-container">
            <div id="chessboard"></div>
        </div>
        
        <div class="sidebar">
            <div class="panel">
                <h2>Game Status</h2>
                <div class="status" id="game-status">White's turn</div>
                <div class="timer" id="white-timer">10:00</div>
                <div class="timer" id="black-timer">10:00</div>
            </div>
            
            <div class="panel">
                <h2>Power Moves</h2>
                <div class="power-moves">
                    <button id="double-move">Double Move</button>
                    <button id="teleport">Teleport</button>
                    <button id="time-freeze">Time Freeze</button>
                    <button id="sacrifice">Sacrifice</button>
                    <button id="clone">Clone</button>
                    <button id="gravity-well">Gravity Well</button>
                </div>
            </div>
            
            <div class="panel">
                <h2>Captured Pieces</h2>
                <div>White captured:</div>
                <div class="captured-pieces" id="white-captured"></div>
                <div>Black captured:</div>
                <div class="captured-pieces" id="black-captured"></div>
            </div>
            
            <div class="panel move-history">
                <h2>Move History</h2>
                <div class="move-list" id="move-history"></div>
            </div>
            
            <div class="panel">
                <h2>Controls</h2>
                <div class="controls">
                    <button class="primary" id="new-game">New Game</button>
                    <button id="undo-move">Undo</button>
                    <button id="flip-board">Flip Board</button>
                    <button class="danger" id="resign">Resign</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            const gameState = {
                board: Array(8).fill().map(() => Array(8).fill(null)),
                turn: 'white',
                selectedPiece: null,
                possibleMoves: [],
                moveHistory: [],
                whiteCaptured: [],
                blackCaptured: [],
                whiteTime: 600, // 10 minutes in seconds
                blackTime: 600,
                timerInterval: null,
                powerMoves: {
                    doubleMove: { white: 1, black: 1 },
                    teleport: { white: 1, black: 1 },
                    timeFreeze: { white: 1, black: 1 },
                    sacrifice: { white: 1, black: 1 },
                    clone: { white: 1, black: 1 },
                    gravityWell: { white: 1, black: 1 }
                },
                gameOver: false,
                flipped: false
            };
            
            // DOM elements
            const chessboard = document.getElementById('chessboard');
            const gameStatus = document.getElementById('game-status');
            const whiteTimer = document.getElementById('white-timer');
            const blackTimer = document.getElementById('black-timer');
            const moveHistory = document.getElementById('move-history');
            const whiteCaptured = document.getElementById('white-captured');
            const blackCaptured = document.getElementById('black-captured');
            
            // Initialize the board
            function initializeBoard() {
                chessboard.innerHTML = '';
                
                // Create squares
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        // Add coordinates
                        if (col === 0) {
                            const rank = document.createElement('div');
                            rank.className = 'coordinates rank';
                            rank.textContent = 8 - row;
                            square.appendChild(rank);
                        }
                        
                        if (row === 7) {
                            const file = document.createElement('div');
                            file.className = 'coordinates file';
                            file.textContent = String.fromCharCode(97 + col);
                            square.appendChild(file);
                        }
                        
                        square.addEventListener('click', () => handleSquareClick(row, col));
                        chessboard.appendChild(square);
                    }
                }
                
                // Set up pieces
                setupPieces();
                updateBoard();
                startTimer();
            }
            
            // Set up initial piece positions
            function setupPieces() {
                // Clear the board
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        gameState.board[row][col] = null;
                    }
                }
                
                // Pawns
                for (let col = 0; col < 8; col++) {
                    gameState.board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
                    gameState.board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
                }
                
                // Rooks
                gameState.board[0][0] = { type: 'rook', color: 'black', hasMoved: false };
                gameState.board[0][7] = { type: 'rook', color: 'black', hasMoved: false };
                gameState.board[7][0] = { type: 'rook', color: 'white', hasMoved: false };
                gameState.board[7][7] = { type: 'rook', color: 'white', hasMoved: false };
                
                // Knights
                gameState.board[0][1] = { type: 'knight', color: 'black' };
                gameState.board[0][6] = { type: 'knight', color: 'black' };
                gameState.board[7][1] = { type: 'knight', color: 'white' };
                gameState.board[7][6] = { type: 'knight', color: 'white' };
                
                // Bishops
                gameState.board[0][2] = { type: 'bishop', color: 'black' };
                gameState.board[0][5] = { type: 'bishop', color: 'black' };
                gameState.board[7][2] = { type: 'bishop', color: 'white' };
                gameState.board[7][5] = { type: 'bishop', color: 'white' };
                
                // Queens
                gameState.board[0][3] = { type: 'queen', color: 'black' };
                gameState.board[7][3] = { type: 'queen', color: 'white' };
                
                // Kings
                gameState.board[0][4] = { type: 'king', color: 'black', hasMoved: false };
                gameState.board[7][4] = { type: 'king', color: 'white', hasMoved: false };
                
                // Reset captured pieces
                gameState.whiteCaptured = [];
                gameState.blackCaptured = [];
                updateCapturedPieces();
            }
            
            // Update the visual board based on game state
            function updateBoard() {
                // Clear all pieces and highlights
                document.querySelectorAll('.piece').forEach(p => p.remove());
                document.querySelectorAll('.square').forEach(sq => {
                    sq.classList.remove('highlight', 'move-hint', 'power-move', 'danger');
                });
                
                // Add pieces to the board
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece) {
                            const square = getSquareElement(row, col);
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.color}`;
                            pieceElement.dataset.type = piece.type;
                            pieceElement.dataset.color = piece.color;
                            pieceElement.style.backgroundImage = `url('https://pieces.vercel.app/${piece.color}/${piece.type}.svg')`;
                            
                            // Add drag events
                            pieceElement.draggable = true;
                            pieceElement.addEventListener('dragstart', (e) => {
                                if (piece.color === gameState.turn && !gameState.gameOver) {
                                    e.dataTransfer.setData('text/plain', `${row},${col}`);
                                    pieceElement.classList.add('dragging');
                                    handleSquareClick(row, col);
                                } else {
                                    e.preventDefault();
                                }
                            });
                            
                            pieceElement.addEventListener('dragend', () => {
                                pieceElement.classList.remove('dragging');
                            });
                            
                            square.appendChild(pieceElement);
                        }
                    }
                }
                
                // Highlight selected piece
                if (gameState.selectedPiece) {
                    const { row, col } = gameState.selectedPiece;
                    getSquareElement(row, col).classList.add('highlight');
                    
                    // Show possible moves
                    gameState.possibleMoves.forEach(move => {
                        const square = getSquareElement(move.row, move.col);
                        if (gameState.board[move.row][move.col]) {
                            square.classList.add('danger');
                        } else {
                            square.classList.add('move-hint');
                        }
                    });
                }
                
                // Update game status
                updateGameStatus();
            }
            
            // Get square DOM element by coordinates
            function getSquareElement(row, col) {
                const index = row * 8 + col;
                return chessboard.children[index];
            }
            
            // Handle square clicks
            function handleSquareClick(row, col) {
                if (gameState.gameOver) return;
                
                const piece = gameState.board[row][col];
                
                // If a piece is already selected
                if (gameState.selectedPiece) {
                    const { row: selectedRow, col: selectedCol } = gameState.selectedPiece;
                    
                    // Check if the clicked square is a valid move
                    const isValidMove = gameState.possibleMoves.some(move => 
                        move.row === row && move.col === col
                    );
                    
                    if (isValidMove) {
                        // Move the piece
                        movePiece(selectedRow, selectedCol, row, col);
                    } else if (piece && piece.color === gameState.turn) {
                        // Select a different piece of the same color
                        selectPiece(row, col);
                    } else {
                        // Deselect
                        deselectPiece();
                    }
                } else if (piece && piece.color === gameState.turn) {
                    // Select a piece
                    selectPiece(row, col);
                }
            }
            
            // Select a piece and calculate possible moves
            function selectPiece(row, col) {
                gameState.selectedPiece = { row, col };
                gameState.possibleMoves = calculatePossibleMoves(row, col);
                updateBoard();
            }
            
            // Deselect the current piece
            function deselectPiece() {
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                updateBoard();
            }
            
            // Calculate possible moves for a piece
            function calculatePossibleMoves(row, col) {
                const piece = gameState.board[row][col];
                if (!piece) return [];
                
                const moves = [];
                const directions = {
                    pawn: { white: -1, black: 1 },
                    rook: [
                        { dr: -1, dc: 0 }, { dr: 1, dc: 0 }, 
                        { dr: 0, dc: -1 }, { dr: 0, dc: 1 }
                    ],
                    knight: [
                        { dr: -2, dc: -1 }, { dr: -2, dc: 1 },
                        { dr: -1, dc: -2 }, { dr: -1, dc: 2 },
                        { dr: 1, dc: -2 }, { dr: 1, dc: 2 },
                        { dr: 2, dc: -1 }, { dr: 2, dc: 1 }
                    ],
                    bishop: [
                        { dr: -1, dc: -1 }, { dr: -1, dc: 1 },
                        { dr: 1, dc: -1 }, { dr: 1, dc: 1 }
                    ],
                    queen: [
                        { dr: -1, dc: 0 }, { dr: 1, dc: 0 }, 
                        { dr: 0, dc: -1 }, { dr: 0, dc: 1 },
                        { dr: -1, dc: -1 }, { dr: -1, dc: 1 },
                        { dr: 1, dc: -1 }, { dr: 1, dc: 1 }
                    ],
                    king: [
                        { dr: -1, dc: 0 }, { dr: 1, dc: 0 }, 
                        { dr: 0, dc: -1 }, { dr: 0, dc: 1 },
                        { dr: -1, dc: -1 }, { dr: -1, dc: 1 },
                        { dr: 1, dc: -1 }, { dr: 1, dc: 1 }
                    ]
                };
                
                // Pawn moves
                if (piece.type === 'pawn') {
                    const direction = directions.pawn[piece.color];
                    const startRow = piece.color === 'white' ? 6 : 1;
                    
                    // Move forward
                    if (isValidSquare(row + direction, col) && !gameState.board[row + direction][col]) {
                        moves.push({ row: row + direction, col });
                        
                        // Double move from starting position
                        if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                            moves.push({ row: row + 2 * direction, col });
                        }
                    }
                    
                    // Captures
                    for (const dc of [-1, 1]) {
                        const newCol = col + dc;
                        if (isValidSquare(row + direction, newCol)) {
                            const target = gameState.board[row + direction][newCol];
                            if (target && target.color !== piece.color) {
                                moves.push({ row: row + direction, col: newCol });
                            }
                        }
                    }
                }
                // Knight moves
                else if (piece.type === 'knight') {
                    for (const { dr, dc } of directions.knight) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidSquare(newRow, newCol)) {
                            const target = gameState.board[newRow][newCol];
                            if (!target || target.color !== piece.color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }
                // Sliding pieces (rook, bishop, queen, king)
                else {
                    const pieceDirections = directions[piece.type];
                    for (const { dr, dc } of pieceDirections) {
                        let newRow = row + dr;
                        let newCol = col + dc;
                        
                        while (isValidSquare(newRow, newCol)) {
                            const target = gameState.board[newRow][newCol];
                            
                            if (!target) {
                                moves.push({ row: newRow, col: newCol });
                            } else {
                                if (target.color !== piece.color) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                                break; // Stop sliding after hitting a piece
                            }
                            
                            // King and knight don't slide
                            if (piece.type === 'king' || piece.type === 'knight') break;
                            
                            newRow += dr;
                            newCol += dc;
                        }
                    }
                }
                
                return moves;
            }
            
            // Check if coordinates are within the board
            function isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            // Move a piece from one square to another
            function movePiece(fromRow, fromCol, toRow, toCol, isPowerMove = false) {
                const piece = gameState.board[fromRow][fromCol];
                if (!piece) return false;
                
                const target = gameState.board[toRow][toCol];
                
                // Check if the move is valid
                const isValid = gameState.possibleMoves.some(move => 
                    move.row === toRow && move.col === toCol
                );
                
                if (!isValid && !isPowerMove) return false;
                
                // Create move notation
                const moveNotation = getMoveNotation(piece, fromRow, fromCol, toRow, toCol, target);
                
                // Capture piece if needed
                if (target) {
                    if (piece.color === 'white') {
                        gameState.whiteCaptured.push(target.type);
                    } else {
                        gameState.blackCaptured.push(target.type);
                    }
                    updateCapturedPieces();
                    
                    // Add explosion effect
                    const explosion = document.createElement('div');
                    explosion.className = 'explosion';
                    getSquareElement(toRow, toCol).appendChild(explosion);
                    
                    setTimeout(() => {
                        explosion.style.opacity = '1';
                        explosion.style.transition = 'opacity 0.5s ease-out';
                        setTimeout(() => {
                            explosion.remove();
                        }, 500);
                    }, 10);
                }
                
                // Move the piece
                gameState.board[toRow][toCol] = { ...piece, hasMoved: true };
                gameState.board[fromRow][fromCol] = null;
                
                // Special moves
                // Pawn promotion
                if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                    gameState.board[toRow][toCol].type = 'queen'; // Auto-queen for simplicity
                    moveNotation.notation += '=Q';
                }
                
                // Add to move history
                gameState.moveHistory.push({
                    ...moveNotation,
                    piece,
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol },
                    captured: target?.type,
                    turn: gameState.turn
                });
                
                updateMoveHistory();
                
                // Animate the move
                animateMove(fromRow, fromCol, toRow, toCol, () => {
                    // Switch turns
                    gameState.turn = gameState.turn === 'white' ? 'black' : 'white';
                    deselectPiece();
                    
                    // Check for game over conditions
                    checkGameOver();
                    
                    // Update UI
                    updateGameStatus();
                });
                
                return true;
            }
            
            // Animate piece movement
            function animateMove(fromRow, fromCol, toRow, toCol, callback) {
                const fromSquare = getSquareElement(fromRow, fromCol);
                const toSquare = getSquareElement(toRow, toCol);
                const pieceElement = fromSquare.querySelector('.piece');
                
                if (!pieceElement) {
                    callback();
                    return;
                }
                
                pieceElement.classList.add('animate');
                
                // Calculate positions
                const fromRect = fromSquare.getBoundingClientRect();
                const toRect = toSquare.getBoundingClientRect();
                const chessboardRect = chessboard.getBoundingClientRect();
                
                const dx = toRect.left - fromRect.left;
                const dy = toRect.top - fromRect.top;
                
                // Apply the movement
                pieceElement.style.transform = `translate(${dx}px, ${dy}px)`;
                
                // After animation completes
                setTimeout(() => {
                    pieceElement.style.transform = '';
                    pieceElement.classList.remove('animate');
                    
                    // Move the piece in the DOM
                    toSquare.appendChild(pieceElement);
                    
                    callback();
                }, 300);
            }
            
            // Generate algebraic notation for a move
            function getMoveNotation(piece, fromRow, fromCol, toRow, toCol, target) {
                const file = String.fromCharCode(97 + fromCol);
                const rank = 8 - fromRow;
                const newFile = String.fromCharCode(97 + toCol);
                const newRank = 8 - toRow;
                
                let notation = '';
                
                if (piece.type !== 'pawn') {
                    notation += piece.type.toUpperCase();
                }
                
                if (target) {
                    if (piece.type === 'pawn') {
                        notation += file;
                    }
                    notation += 'x';
                }
                
                notation += `${newFile}${newRank}`;
                
                return {
                    notation,
                    san: notation,
                    fromRow, fromCol, toRow, toCol
                };
            }
            
            // Update the move history display
            function updateMoveHistory() {
                moveHistory.innerHTML = '';
                
                // Group moves by turn
                for (let i = 0; i < gameState.moveHistory.length; i += 2) {
                    const whiteMove = gameState.moveHistory[i];
                    const blackMove = gameState.moveHistory[i + 1];
                    
                    const moveGroup = document.createElement('div');
                    moveGroup.style.display = 'contents'; // For grid layout
                    
                    const moveNumber = document.createElement('div');
                    moveNumber.textContent = `${i / 2 + 1}.`;
                    moveGroup.appendChild(moveNumber);
                    
                    const whiteMoveElement = document.createElement('div');
                    whiteMoveElement.textContent = whiteMove.notation;
                    whiteMoveElement.classList.toggle('active', i === gameState.moveHistory.length - 1 && whiteMove.turn === 'white');
                    whiteMoveElement.addEventListener('click', () => replayMove(i));
                    moveGroup.appendChild(whiteMoveElement);
                    
                    if (blackMove) {
                        const blackMoveElement = document.createElement('div');
                        blackMoveElement.textContent = blackMove.notation;
                        blackMoveElement.classList.toggle('active', i + 1 === gameState.moveHistory.length - 1 && blackMove.turn === 'black');
                        blackMoveElement.addEventListener('click', () => replayMove(i + 1));
                        moveGroup.appendChild(blackMoveElement);
                    }
                    
                    moveHistory.appendChild(moveGroup);
                }
                
                // Scroll to bottom
                moveHistory.scrollTop = moveHistory.scrollHeight;
            }
            
            // Replay a move from history
            function replayMove(moveIndex) {
                // Reset to initial position
                setupPieces();
                
                // Replay all moves up to the selected one
                for (let i = 0; i <= moveIndex; i++) {
                    const move = gameState.moveHistory[i];
                    gameState.board[move.to.row][move.to.col] = { ...move.piece };
                    gameState.board[move.from.row][move.from.col] = null;
                    
                    if (move.captured) {
                        if (move.piece.color === 'white') {
                            gameState.whiteCaptured.push(move.captured);
                        } else {
                            gameState.blackCaptured.push(move.captured);
                        }
                    }
                }
                
                // Update the turn
                gameState.turn = moveIndex % 2 === 0 ? 'black' : 'white';
                
                updateCapturedPieces();
                updateBoard();
            }
            
            // Update captured pieces display
            function updateCapturedPieces() {
                whiteCaptured.innerHTML = '';
                blackCaptured.innerHTML = '';
                
                gameState.whiteCaptured.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'captured-piece';
                    pieceElement.style.backgroundImage = `url('https://pieces.vercel.app/black/${piece}.svg')`;
                    whiteCaptured.appendChild(pieceElement);
                });
                
                gameState.blackCaptured.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'captured-piece';
                    pieceElement.style.backgroundImage = `url('https://pieces.vercel.app/white/${piece}.svg')`;
                    blackCaptured.appendChild(pieceElement);
                });
            }
            
            // Update game status text
            function updateGameStatus() {
                if (gameState.gameOver) {
                    gameStatus.textContent = gameState.gameOver;
                    return;
                }
                
                gameStatus.textContent = `${gameState.turn === 'white' ? 'White' : 'Black'}'s turn`;
                
                // Check for check
                const kingPos = findKing(gameState.turn);
                if (isSquareUnderAttack(kingPos.row, kingPos.col, gameState.turn === 'white' ? 'black' : 'white')) {
                    gameStatus.textContent += ' (Check!)';
                    getSquareElement(kingPos.row, kingPos.col).classList.add('danger');
                }
            }
            
            // Find the king's position
            function findKing(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            return { row, col };
                        }
                    }
                }
                return { row: -1, col: -1 }; // Should never happen
            }
            
            // Check if a square is under attack
            function isSquareUnderAttack(row, col, byColor) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = gameState.board[r][c];
                        if (piece && piece.color === byColor) {
                            const moves = calculatePossibleMoves(r, c);
                            if (moves.some(move => move.row === row && move.col === col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // Check for game over conditions
            function checkGameOver() {
                // Check for checkmate or stalemate
                const kingPos = findKing(gameState.turn);
                const inCheck = isSquareUnderAttack(kingPos.row, kingPos.col, gameState.turn === 'white' ? 'black' : 'white');
                
                // Check if any legal moves exist
                let hasLegalMoves = false;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.color === gameState.turn) {
                            const moves = calculatePossibleMoves(row, col);
                            if (moves.length > 0) {
                                hasLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasLegalMoves) break;
                }
                
                if (inCheck && !hasLegalMoves) {
                    gameState.gameOver = `Checkmate! ${gameState.turn === 'white' ? 'Black' : 'White'} wins!`;
                    stopTimer();
                } else if (!inCheck && !hasLegalMoves) {
                    gameState.gameOver = "Stalemate! It's a draw!";
                    stopTimer();
                }
                
                updateGameStatus();
            }
            
            // Timer functions
            function startTimer() {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                
                gameState.timerInterval = setInterval(() => {
                    if (gameState.turn === 'white') {
                        gameState.whiteTime--;
                    } else {
                        gameState.blackTime--;
                    }
                    
                    updateTimers();
                    
                    // Check for timeout
                    if (gameState.whiteTime <= 0) {
                        gameState.gameOver = "Time's up! Black wins!";
                        stopTimer();
                        updateGameStatus();
                    } else if (gameState.blackTime <= 0) {
                        gameState.gameOver = "Time's up! White wins!";
                        stopTimer();
                        updateGameStatus();
                    }
                }, 1000);
            }
            
            function stopTimer() {
                if (gameState.timerInterval) {
                    clearInterval(gameState.timerInterval);
                    gameState.timerInterval = null;
                }
            }
            
            function updateTimers() {
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
                };
                
                whiteTimer.textContent = formatTime(gameState.whiteTime);
                blackTimer.textContent = formatTime(gameState.blackTime);
                
                // Add warning for low time
                whiteTimer.classList.toggle('danger', gameState.whiteTime <= 30 && gameState.turn === 'white');
                blackTimer.classList.toggle('danger', gameState.blackTime <= 30 && gameState.turn === 'black');
            }
            
            // Power moves
            function setupPowerMoves() {
                document.getElementById('double-move').addEventListener('click', () => {
                    if (gameState.powerMoves.doubleMove[gameState.turn] > 0 && gameState.selectedPiece) {
                        gameState.powerMoves.doubleMove[gameState.turn]--;
                        
                        // Show possible double moves
                        const { row, col } = gameState.selectedPiece;
                        const piece = gameState.board[row][col];
                        const moves = calculatePossibleMoves(row, col);
                        
                        // For each possible move, calculate moves from there
                        const doubleMoves = [];
                        moves.forEach(move => {
                            // Simulate moving there
                            const originalPiece = gameState.board[move.row][move.col];
                            gameState.board[move.row][move.col] = piece;
                            gameState.board[row][col] = null;
                            
                            const secondMoves = calculatePossibleMoves(move.row, move.col);
                            secondMoves.forEach(secondMove => {
                                doubleMoves.push({
                                    from: { row, col },
                                    via: { row: move.row, col: move.col },
                                    to: { row: secondMove.row, col: secondMove.col }
                                });
                            });
                            
                            // Undo simulation
                            gameState.board[move.row][move.col] = originalPiece;
                            gameState.board[row][col] = piece;
                        });
                        
                        // Highlight double moves
                        doubleMoves.forEach(move => {
                            const square = getSquareElement(move.to.row, move.to.col);
                            square.classList.add('power-move');
                            
                            // Add click handler
                            square.addEventListener('click', function powerMoveHandler() {
                                // Move piece via intermediate square
                                movePiece(move.from.row, move.from.col, move.via.row, move.via.col, true);
                                setTimeout(() => {
                                    movePiece(move.via.row, move.via.col, move.to.row, move.to.col, true);
                                }, 350);
                                
                                // Remove all power move highlights
                                document.querySelectorAll('.power-move').forEach(sq => {
                                    sq.classList.remove('power-move');
                                    sq.removeEventListener('click', powerMoveHandler);
                                });
                            }, { once: true });
                        });
                    }
                });
                
                document.getElementById('teleport').addEventListener('click', () => {
                    if (gameState.powerMoves.teleport[gameState.turn] > 0 && gameState.selectedPiece) {
                        gameState.powerMoves.teleport[gameState.turn]--;
                        
                        const { row, col } = gameState.selectedPiece;
                        const piece = gameState.board[row][col];
                        
                        // Highlight all empty squares
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                if (!gameState.board[r][c]) {
                                    const square = getSquareElement(r, c);
                                    square.classList.add('power-move');
                                    
                                    // Add click handler
                                    square.addEventListener('click', function teleportHandler() {
                                        // Create teleport effect
                                        const effect = document.createElement('div');
                                        effect.className = 'power-move-effect';
                                        square.appendChild(effect);
                                        
                                        setTimeout(() => {
                                            effect.style.opacity = '0';
                                            effect.style.transition = 'opacity 0.5s ease-out';
                                            setTimeout(() => effect.remove(), 500);
                                        }, 10);
                                        
                                        // Move the piece
                                        movePiece(row, col, r, c, true);
                                        
                                        // Remove all teleport highlights
                                        document.querySelectorAll('.power-move').forEach(sq => {
                                            sq.classList.remove('power-move');
                                            sq.removeEventListener('click', teleportHandler);
                                        });
                                    }, { once: true });
                                }
                            }
                        }
                    }
                });
                
                // Other power moves would be implemented similarly
            }
            
            // Flip the board perspective
            function flipBoard() {
                gameState.flipped = !gameState.flipped;
                chessboard.style.transform = gameState.flipped ? 'rotate(180deg)' : 'rotate(0)';
                
                // Flip each piece
                document.querySelectorAll('.piece').forEach(piece => {
                    piece.style.transform = gameState.flipped ? 'rotate(180deg)' : 'rotate(0)';
                });
                
                // Flip coordinates
                document.querySelectorAll('.coordinates').forEach(coord => {
                    coord.style.transform = gameState.flipped ? 'rotate(180deg)' : 'rotate(0)';
                });
            }
            
            // Initialize the game
            function initGame() {
                gameState.turn = 'white';
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.moveHistory = [];
                gameState.whiteTime = 600;
                gameState.blackTime = 600;
                gameState.gameOver = false;
                
                setupPieces();
                updateBoard();
                startTimer();
                updateGameStatus();
            }
            
            // Event listeners for controls
            document.getElementById('new-game').addEventListener('click', initGame);
            document.getElementById('undo-move').addEventListener('click', () => {
                if (gameState.moveHistory.length > 0) {
                    const lastMove = gameState.moveHistory.pop();
                    
                    // Reset the board to before the move
                    gameState.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
                    gameState.board[lastMove.to.row][lastMove.to.col] = null;
                    
                    // Return captured piece if any
                    if (lastMove.captured) {
                        if (lastMove.piece.color === 'white') {
                            gameState.whiteCaptured.pop();
                        } else {
                            gameState.blackCaptured.pop();
                        }
                        gameState.board[lastMove.to.row][lastMove.to.col] = { 
                            type: lastMove.captured, 
                            color: lastMove.piece.color === 'white' ? 'black' : 'white'
                        };
                    }
                    
                    // Switch turn back
                    gameState.turn = lastMove.turn;
                    gameState.gameOver = false;
                    
                    updateCapturedPieces();
                    updateMoveHistory();
                    updateBoard();
                    startTimer();
                }
            });
            
            document.getElementById('flip-board').addEventListener('click', flipBoard);
            document.getElementById('resign').addEventListener('click', () => {
                gameState.gameOver = `${gameState.turn === 'white' ? 'White' : 'Black'} resigns! ${gameState.turn === 'white' ? 'Black' : 'White'} wins!`;
                stopTimer();
                updateGameStatus();
            });
            
            // Drag and drop for pieces
            chessboard.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            chessboard.addEventListener('drop', (e) => {
                e.preventDefault();
                if (!gameState.selectedPiece) return;
                
                const data = e.dataTransfer.getData('text/plain');
                const [fromRow, fromCol] = data.split(',').map(Number);
                
                // Find which square was dropped on
                const dropTarget = e.target.closest('.square');
                if (!dropTarget) return;
                
                const toRow = parseInt(dropTarget.dataset.row);
                const toCol = parseInt(dropTarget.dataset.col);
                
                // Check if the move is valid
                const isValid = gameState.possibleMoves.some(move => 
                    move.row === toRow && move.col === toCol
                );
                
                if (isValid) {
                    movePiece(fromRow, fromCol, toRow, toCol);
                }
            });
            
            // Initialize everything
            initializeBoard();
            setupPowerMoves();
            initGame();
        });
    </script>
</body>
</html>
